To extend One Ring, you need to implement an [Operation](./Commons/src/main/java/ash/nazg/spark/Operation.java) class according to a set of conventions described in this doc.

First off, you should create a Maven module. Place it at the same level as root pom.xml and include in its `&lt;modules>` section. You may freely choose the group and artifact IDs.

To make One Ring know your module, include its artifact reference in TaskWrapper's `&lt;dependencies>`. To make your module know One Ring, include a reference of artifact 'ash.nazg:Commons' in your module's `&lt;dependencies>` (and test jar too), for example, look [Math's pom.xml](./Math/pom.xml).

Now you need to create an Operation package and describe it.

By convention, it must be named `your.package.name.operations` and have `package-info.java` annotated with `@ash.nazg.config.tdl.Description`, otherwise One Ring won't recognize the contents of `your.package.name`. [There's an example](./Math/src/main/java/ash/nazg/math/operations/package-info.java).

Place all your Operations there.

If your module contain a number of Operation that share same configuration parameters, names of these parameters must be placed in `public final class your.package.name.config.ConfigurationParameters` as `public static final String` constants with same `@Description` annotation each. An Operation can define its own parameters inside its class following the same convention.

Parameter names must have a prefix depending of its purpose:
 * 'DS_INPUT_' for input DataStreams references,
 * 'DS_OUTPUT_' for output DataStreams references,
 * 'DEF_' for any default value,
 * 'OP_' for the operation's Parameter,
 * 'GEN_' for any column, generated by this Operation.
 
 References to columns of input DataStreams must end with '_COLUMN' suffix, and to column lists with '_COLUMNS'.
 
 An Operation in essence is an
 ```java
public abstract class Operation implements Serializable {
    public abstract Map<String, JavaRDDLike> getResult(Map<String, JavaRDDLike> input) throws Exception;
}
```
but enlightened with a surplus metadata that allows One Ring to flexibly configure it, and to ensure the correctness and consistency of all Operation configurations in the Process chain.

It is up to you to provide all that metadata. In the lack of any metadata the build will be failed by the One Ring Guardian.

At the very least, you implement the following methods:
* `abstract public String verb()` that returns a short symbolic name to reference your Operation instance in the config file, annotated with a `@Description`,
* `abstract public TaskDescriptionLanguage.Operation description()` that defines Operation's entire configuration space,
* the `getResult()` that contains an entry point of your business code. It'll be fed with all DataStreams accumulated by the current Process at the point of your Operation invocation, and should return any DataStreams your Operation should emit.

Also you override `public void setConfig(OperationConfig config) throws InvalidConfigValueException` that must call `super()` at the beginning and then read all parameters from the configuration space to your Operation class' fields. If any of the parameters has invalid value, you're obliged to throw an `InvalidConfigValueException` with a descriptive message about the mistake.

You absolutely should create a test case for your Operation. See existing tests for some best practices.

There are a plenty of examples to learn by, just look into the source code for Operation's descendants.
 
There's a list of most notable ones:
* [FilterByDateOperation](./DateTime/src/main/java/ash/nazg/datetime/operations/FilterByDateOperation.java) with lots of parameter of different types that have defaults,
* [SplitByDateOperation](./DateTime/src/main/java/ash/nazg/datetime/operations/SplitByDateOperation.java) — its sister Operation generates a lot of output DataStreams with wildcard names,
* [DummyOperation](./Commons/src/main/java/ash/nazg/commons/operations/DummyOperation.java) — this one properly does nothing, just creates aliases for its input DataStreams,
* [SubtractOperation](./Commons/src/main/java/ash/nazg/commons/operations/SubtractOperation.java) — can consume and emit both RDDs and PairRDDs as DataStreams,
* [WeightedSumOperation](./Math/src/main/java/ash/nazg/math/operations/WeightedSumOperation.java) — generates a lot of columns that either come from input DataStreams or are created anew,
* package [Proximity](./Proximity/src/main/java/ash/nazg/proximity/operations/package-info.java) contains Operations that deal with Point and Polygon RDDs in their DataStreams.

